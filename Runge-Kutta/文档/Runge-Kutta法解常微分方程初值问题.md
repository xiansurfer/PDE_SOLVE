# Runge-Kutta法解常微分方程初值问题

## 1.为什么要用Runge-Kutta

​		常微分方程初值问题如下:
$$
\begin{cases}
\frac{dy}{dx}=f(x,y(x))\\
y(x_0)=y_0
\end{cases}
$$
​		欧拉法解决常微分方程初值问题的精度是很低的，需要找到精度更高的方法

​		初值问题用泰勒展开表示如下(在x=xn处展开)：
$$
y(x)=y({x_n})+
\frac{\dot{y}}{1!}(x-x_{n})+
\frac{\ddot{y}}{2!}(x-x_{n})^2+
...+
\frac{y^{p}}{p!}(x-x_{n})^p+
O(h^{p+1})
$$
​		令:
$$
x=x_{n+1}=x_n+h
$$
​		得到
$$
y(x_{n+1})=y({x_n})+
\frac{\dot{y}}{1!}h+
\frac{\ddot{y}}{2!}(h)^2+
...+
\frac{y^{p}}{p!}(h)^p+
O(h^{p+1})
$$
​		由此，我们可以得到任何精度下的初值问题的解，但是求解各阶导数是十分复杂的，所以需要构造RK方法

## 2.构造RK方法

​		初值问题的积分表示
$$
y(x_{n+1})=y(x_n)+\int_{x_n}^{x_{n+1}}f(x,y(x))dx
$$
​		欧拉的方法是将积分的精确值以矩形的面积来替代，矩形的宽就是h,高是f(xn,yn)  (欧拉向后方法)，或者高是f(xn+1,yn+1)  (欧拉向前法)

​		再或者将积分的精确值以梯形的面积来代替，那么梯形的上下底分别为f(xn,yn) 和f(xn+1,yn+1)，高为h，这就是梯形法

​		梯形法实际上就是将两端点处的函数值(矩形的两个高)算术平均之后，再与步长h相乘。那么就是说，可以在两端点之间，构造m个节点，把每一点的函数值（矩形的高），加权平均起来，再乘以步长h (宽)，那么只要节点找的合适，加权平均系数找的合适，就可以使得对积分的近似更加精确

​		所以RK方法可以表示为：
$$
y(x_{n+1})=y(x_n)+h\sum_{i=1}^{m}w_iK_i
$$
​		w表示加权系数，Ki表示第i个节点的函数值，因为这个函数是y(x)的导函数，实质上就是斜率，就用K来表示	

​	![初值问题示意图](fig\初值问题示意图.png)

​		在区间[xn,xn+1]上取m个适当的点，满足
$$
t_1=x_n \leq t_2 \leq t_3... \leq t_m \leq x_{n+1}
$$
​		(1)取适当的系数a,系数a控制t点的位置
$$
t_i=x_n+a_ih \\
0 \leq a_i\leq1,i=1,2,...m(a_1=0)
$$
​		t1实际上就是xn，那么此时a1为0

​		（2）选取合适的系数组合
$$
0 \leq w_i \leq1 ,i=1,2,...m \\w_1+w_2+...w_m=1
$$
​		（3）选取相关参数来计算Ki

​		第一个节点：

​		这个点实际上就是xn,那么
$$
t_1=x_n+a_1*h,a_1=0
$$

$$
K_1=f(t_1,y(t_1))=f(x_n,y(x_n))
$$

​		第二个节点：
$$
t_2=x_n+a_2h
$$

$$
K_2=f(t_2,y(t_2))=f(x_n+a_2h,y(t_2))
$$

​		可以从上图看到，$$y(t_2)$$就相当于$$y(t_1)$$加上$$x_n$$到$$t_2$$间的曲边梯形的面积，那么$$y(t_2)$$可以表示为：
$$
y(t_2)=y(x_n)+(t_2-x_n)\times K_1
$$

$$
y(t_2)=y_n+ha_2K_1
$$

​		所以：
$$
K_2=f(t_2,y(t_2))=f(x_n+a_2h,y_n+ha_2K_1)
$$

$$
K_2=f(t_2,y(t_2))=f(x_n+a_2h,y_n+hb_{21}K_1)
$$

​		这里把$$a_2$$变换为了$$b_{21}$$,是因为这里计算的是第一个矩形，所以第一个矩形的宽正好是$$a_2$$，但对于之后的矩形来说，不好用a来表示，所以把每一个小曲边梯形的宽用b来表示，但对于b来说，他们的和可以用a来表示，比如对于前两个矩形来说，他们对应的b加起来正好等于$$a_3$$。看到这里对于下面的式子就好理解了。
$$
K_3=f(t_3,y(t_3))=f(x_n+a_3h,y_n+h(b_{31}K_1+b_{32}K_2))
$$

$$
b_{31}+b_{32}=a_3
$$

​		以此类推：
$$
K_m=f(t_m,y(t_m))=f(x_n+a_mh,h(b_{m1}K_1+...b_{m,m-1}K_{m-1}))
$$

$$
b_{m1}+b_{m2}+...+b_{m,m-1}=a_m
$$

​		到此可以得到RK法的一般形式，在这里总结一下：
$$
\begin{cases}
y_{n+1}=y_n+h \sum_{i=1}^{m}w_iK_i \\
K_1 = f(x_n,y_n) \\
K_2 = f(x_n+a_2h,y_n+hb_{21}K_1) \\
K_3 = f(x_n+a_3h,y_n+h(b_{31}K_1+b_{32}K_2)) \\
...................\\
K_m=f(x_n+a_mh,y_n+h(b_{m1}K_1+...b_{m,m-1}K_{m-1}))
\end{cases}
$$
​		其中
$$
0 \leq a_i \leq 1,i=1,2,3...,m
$$
​		且
$$
w_1+w_2+...+w_i=1\\
\begin{cases}
b_{21}=a_2 \\
b_{31}+b_{32}=a_3\\
...... \\
b_{m1}+...+b_{m,m-1}=a_m
\end{cases}
$$
​		如果m取1，实际上一阶RK方法就是欧拉法

​		理论上RK方法可以不用求复杂的高阶导数，就可以获得任意精度下的解，关键是取合适的系数，这里的推导比较复杂，我觉得没有必要继续推下去，只需掌握常用的RK方法格式，编程实现可以解决问题即可。具体看代码。
